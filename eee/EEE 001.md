# **EEE 001: The Minimal Viable Core**

**Author:** Vitali

**Status:** Draft

**Created:** 2025-09-22

## **Abstract**

This EEE proposes the architecture and design of the Minimal Viable Core (MVC) for Eminix, a modern, performance-oriented, and highly extensible text editor. To achieve these goals, the MVC is built on a hangs-free, event-driven architecture in Rust, featuring a decoupled UI and a powerful scripting system.

The MVC establishes the foundational components—event loop, buffer management, command execution, and a minimal text-based user interface (TUI)—upon which all future functionality will be built.

## **Terminology**

Proposal documents for Eminix are called EEEs, a recursive acronym for *Eminix Enhancement EEE*. This naming reflects the project's inspiration from the self-referential traditions of GNU.

## **The Zen of Eminix**

Eminix is guided by a set of core principles that shape all design and architectural decisions:

1. ***Extensibility is Key:*** The editor is a powerful core, not a monolithic application. If a feature can be implemented as a script or plugin, it should be.  
2. ***Flow, Uninterrupted:*** The user interface must never be blocked by backend processes. All components are asynchronous, ensuring fluid responsiveness. It's a promise to the user.  
3. ***There is a Mode for Everyone:*** Modes tailor the interface and functionality to specific tasks, from text editing to file management and beyond.  
4. ***Do one thing, and do it well:*** Each component should have a single, focused responsibility. This philosophy (the Single Responsibility Principle) is the key to building a modular, resilient, and maintainable system.

## **Motivation**

The text editor landscape is polarized:

* **Legacy editors** such as Emacs and Vim provide unparalleled extensibility but suffer from performance overhead and architectural complexity.  
* **Modern editors** such as VS Code offer smooth experiences but often at the expense of deep, keyboard-driven customizability.

Eminix aims to bridge this gap. It is designed for the *advanced casual key presser*—a user who may not be a programmer but works extensively with text (e.g., writers, scientists using LaTeX, GTD/Zettelkasten practitioners). Eminix provides a modal, keyboard-centric, and fully customizable environment. The MVC architecture outlined here is the foundation for delivering this experience without the compromises of existing editors.

## **Target Audience**

The ideal Eminix user seeks a single, powerful tool for diverse text-centric workflows. The MVC will lay the groundwork for an out-of-the-box experience that includes modes for:

* File management with integrated full-text search.  
* Git client front-end.  
* Markdown/Org-mode for GTD and Zettelkasten systems.  
* Scientific writing with LaTeX.  
* PDF organization and annotation.

## **Technical Specification**

### **1\. Core Loop & Event System**

* **Architecture:** A decentralized, many-to-many event-driven model based on a microkernel philosophy.  
* **Component Granularity & Design:** The architecture is composed of small, independent components that communicate via the event bus. The design of these components is governed by the Single Responsibility Principle (SRP).  
* **State Management & Concurrency:** The architecture formally adopts the Actor Model to manage state and concurrency.  
* **Communication Patterns:** The system supports two primary communication patterns: "Fire-and-Forget" and "Request/Response".  
* **Process Model & IPC:** The UI runs as a separate process from the core daemon, communicating via IPC with a unified event model.  
* **Event Structure, Bus, and Guarantees:** The system uses a high-performance MPMC bus with per-sender ordering guarantees.  
* **Delivery Semantics & Backpressure:** The event system provides a multi-level Quality of Service (QoS) to ensure both responsiveness and data integrity.  
  * **Critical Events (e.g., user commands, file operations):** These are transmitted over lossless, bounded channels. If a receiving actor's mailbox is full, the sender will wait (asynchronously), creating backpressure that guarantees delivery. This ensures no user command is ever dropped.  
  * **Ephemeral Events (e.g., UI updates, mouse movements):** These are transmitted over lossy channels. If the system is under heavy load and a receiver's mailbox is full, new events of this type will be dropped. This "load shedding" prevents event storms from causing UI hangs, prioritizing a fluid user experience.  
* **Event Prioritization & Cancellation:** To ensure UI responsiveness under all conditions, the event system includes a prioritization model. Events are categorized into priority levels, and long-running, low-priority tasks are cancellable.  
  * **Priority Levels:** Events are tagged with a priority (High, Normal, Low). High priority is reserved for user input and UI updates to guarantee immediate feedback. Low priority is for background tasks like indexing or searching.  
  * **Priority-Aware Mailboxes:** Each actor processes events from a set of priority queues, always handling High priority events before any others. This prevents low-priority event storms from causing input lag.  
  * **Cancellable Tasks:** Low-priority, long-running commands (e.g., a workspace search) are designed to be cancellable. They are issued with a cancellation token that allows the requesting component to terminate the task early if it is no longer needed, conserving system resources.

### **2\. Buffer Management**

* **Data Structure:** Initial implementation uses a Gap Buffer.  
* **API:** A thread-safe, abstracted API for all buffer interactions.  
* **Reactivity:** Buffers are first-class participants in the event system, emitting events for modifications, saves, and other state changes.  
* **Undo/Redo & Crash Recovery:** To ensure data integrity and provide a robust undo/redo mechanism, each buffer will maintain an operation log.  
  * **Write-Ahead Log (WAL):** All modifications (insertions, deletions) are first recorded as operations in a per-buffer WAL before being applied. This log is the source of truth for both undo/redo (by traversing the log) and crash recovery (by replaying the log).  
  * **Periodic Snapshots:** To ensure fast recovery times, the full state of a buffer will be periodically snapshotted. Recovery will involve loading the latest snapshot and replaying only the subsequent operations from the WAL.  
* **File I/O & Data Integrity:** File saving operations are designed to be atomic and safe against crashes.  
  * **Atomic Save Strategy:** Files are saved using a "write-to-temp-then-rename" strategy. This ensures that the original file is never left in a partially written or corrupted state if the editor crashes mid-save.  
  * **Log Compaction:** Upon a successful save, the corresponding WAL is flushed and can be compacted or truncated, as the saved file now represents a new, persistent snapshot.

### **3\. Command Execution & Keybinding System**

* **Command Signature:** All commands are async to enforce the hangs-free principle.  
* **Keymap Layers:** A hierarchical model (Global → Major Mode → Minor Mode).  
* **Configuration Syntax:** Defined programmatically in user scripts.

### **4\. Extensibility & Configuration**

* **Configuration as Scripts:** User configuration is executable code.  
* **Scripting Language:** The primary candidate is Rhai, with a design that allows for future alternatives.  
* **Handling Asynchronicity:** Synchronous scripts are safely executed in a dedicated, blocking-aware thread pool and interact with the async core via an event-driven, callback-style API.  
* **API Surface:** A minimal but powerful API for buffers, windows, commands, and events.

### **5\. Security Model**

Eminix is designed with a multi-layered security model to isolate components and limit the "blast radius" of bugs or malicious code.

* **Layer 1: Process Isolation**  
  * The UI runs in a separate OS process from the core daemon. A crash or freeze in the UI process cannot affect the core editor state, ensuring data integrity. Communication occurs exclusively over a structured IPC channel.  
* **Layer 2: Actor Isolation**  
  * Within the core daemon, each component is an isolated Actor. Adherence to the Actor Model prevents bugs in one component (e.g., syntax highlighting) from corrupting the internal state of another (e.g., the buffer manager).  
* **Layer 3: Script Sandboxing**  
  * User scripts are executed in a tightly controlled sandbox with no direct access to the system. This sandbox enforces two types of security: capability-based permissions and resource management.  
  * ***Capability Model:*** A script's permissions are determined by the capabilities granted to it via its CommandContext.  
    * **Granted Capabilities:** Scripts can dispatch commands, emit events, and query editor state through the official, mediated API.  
    * **Denied Capabilities:** Scripts are explicitly denied direct filesystem access, direct network access, and the ability to use a Foreign Function Interface (FFI) to load native code. All such operations must be requested through the core, which acts as a security gatekeeper.  
  * ***Resource Management & DoS Prevention:*** To protect the editor from buggy or malicious scripts that could lead to denial-of-service (DoS), the sandbox enforces strict, configurable resource limits.  
    * **Compute (CPU):** To prevent infinite loops, the script engine will enforce a maximum instruction count for each script execution.  
    * **API Rate Limiting:** To prevent scripts from overwhelming the event bus, API functions will be rate-limited using a token bucket algorithm.  
    * **Memory:** The script engine will be configured with a hard memory cap. Any script attempting to allocate memory beyond this limit will be immediately terminated.

### **6\. API Stability & Versioning**

Building a thriving ecosystem requires a stable and predictable API.

* **Initial Phase (v0.x):** The MVC and initial releases will have an unstable API, subject to change as the core architecture is refined. All releases in this phase will be considered pre-release.  
* **Versioning Scheme:** The project will adhere to Semantic Versioning (SemVer). Breaking changes to the scripting API will only be permitted in major version releases (e.g., 2.0.0).

### **7\. License**

The Eminix project will be licensed under the **Apache License, Version 2.0**.

### **8\. Observability & Debugging**

An event-heavy, decentralized system requires robust observability tools from day one.

* **Structured Tracing:** The tracing crate will be used throughout the core to provide structured, contextual logs. Spans will be used to trace the causality of events through the system.  
* **Real-time Event Log:** A built-in EventLoggerActor will subscribe to all events on the bus, providing a live, filterable log of system activity for debugging.  
* **Introspection Tools:** A built-in inspect-system command will provide runtime introspection, allowing users to query the state of the system for debugging and analysis.